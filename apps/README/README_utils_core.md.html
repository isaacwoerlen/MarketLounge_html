<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>README_utils_core.md</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>README_utils_core.md</h1>
    <pre><code>utils_core README


üß± Structure modulaire de utils_core (1 fichier = 1 r√¥le)



üìÅ Fichier
üéØ R√¥le unique et clair
üîß Fonctions / Contenu principal
üì¶ Utilis√© par ‚â• 3 apps



utils.py
Fonctions utilitaires g√©n√©riques (non m√©tier)
compute_checksum (idempotence), retry_on_exception (robustesse), slugify (URL-safe), Timer (latence), normalize_text, log_metric (r√©-exports)
‚úÖ Oui


validators.py
Validation et normalisation de champs m√©tier/techniques
validate_lang, normalize_locale (BCP-47), validate_tenant_id, validate_scope, validate_checksum, validate_json_field
‚úÖ Oui


text_cleaning.py
Pr√©-traitement et nettoyage de texte pour queries/traductions
normalize_text (queries in matching, source_text in language, prompts in LLM_ai), remove_accents, strip_html, standardize_whitespace
‚úÖ Oui


metrics.py
Standardisation des m√©triques et observabilit√©
log_metric, format_tags, record_metric_wrapper (latency/success/error avec tags dynamiques)
‚úÖ Oui


alerts.py
Validation et manipulation des alertes structur√©es
validate_alerts, format_alert, merge_alerts (int√©gr√© avec errors.AlertException)
‚úÖ Oui


json_utils.py
Fonctions robustes pour manipuler du JSON
safe_json_loads, safe_json_dumps, extract_json_field
‚úÖ Oui


env.py
Acc√®s s√©curis√© aux variables d‚Äôenvironnement et config
get_env_variable (settings comme EMBEDDING_DIM, LLM_TIMEOUT), load_env_config, is_env_valid
‚úÖ Oui


constants.py
Centralisation des constantes partag√©es (regex, lang codes, scopes, m√©triques)
LANG_CODES, REGEX_PATTERNS, DEFAULT_SCOPES, ALERT_TYPES, METRIC_MATCH_*
‚úÖ Oui


types.py
D√©finition des types partag√©s (TypedDict, dataclasses, etc.)
Alert, Payload, MetricTags, TenantInfo, MatchFilters, TranslationJobPayload
‚úÖ Oui


errors.py
Gestion des erreurs g√©n√©riques et structur√©es
AppError, ValidationError, RetryableError, AlertException (avec merge_alerts)
‚úÖ Oui


time_utils.py
Utilitaires pour gestion du temps et timestamps
utc_now, timestamp_ms, format_duration, parse_iso8601
‚úÖ Oui


logging_utils.py
Configuration et gestion des logs structur√©s
setup_logging, get_logger, log_with_tags, log_exception
‚úÖ Oui



üì¶ Utilisation
Chaque app (language, matching, curation, market, etc.) peut importer uniquement les modules n√©cessaires :
from utils_core.utils import compute_checksum, retry_on_exception, slugify, Timer  # Utilitaires g√©n√©riques
from utils_core.validators import normalize_locale, validate_lang  # Normalisation/validation BCP-47
from utils_core.text_cleaning import normalize_text  # Queries, source_text, prompts
from utils_core.metrics import log_metric, record_metric_wrapper  # Monitoring latency/success
from utils_core.types import MatchFilters, TranslationJobPayload  # Typage
from utils_core.env import get_env_variable  # Settings partag√©s
from utils_core.alerts import validate_alerts, merge_alerts  # Alertes SEO/validations
from utils_core.errors import AlertException  # Erreurs avec alertes

Exemples par App
Language
from utils_core.utils import compute_checksum, Timer
from utils_core.validators import normalize_locale, validate_lang
from utils_core.text_cleaning import normalize_text
from utils_core.metrics import record_metric_wrapper
from utils_core.env import get_env_variable

# Normaliser et valider une langue
lang = normalize_locale("pt_BR")  # -> 'pt-br'
validate_lang(lang)

# Calculer checksum pour Translation.source_checksum
checksum = compute_checksum("Soudure inox 316L")

# Normaliser texte avant traduction
source_text = normalize_text("<p>Caf√© fran√ßais</p>", remove_accents_flag=True)

# Mesurer latence traduction
with Timer() as t:
    batch_translate_scope("seo:title", "fr", ["en"])
print(f"Translation took {t.elapsed_ms}ms")

# Instrumenter une t√¢che de traduction
@record_metric_wrapper('lang.batch_translate', static_tags={'operation': 'batch'})
def batch_translate_scope(scope, source_lang, target_langs): ...

# R√©cup√©rer config partag√©e
batch_size = get_env_variable("LANG_BATCH_SIZE", cast="int", default=200)

Matching
from utils_core.utils import retry_on_exception, slugify, Timer
from utils_core.validators import validate_tenant_id, normalize_locale
from utils_core.text_cleaning import normalize_text
from utils_core.metrics import record_metric_wrapper, METRIC_MATCH_DIRTY_RATIO
from utils_core.types import MatchFilters

# Valider tenant_id et normaliser query
validate_tenant_id("tenant_123")
query = normalize_text("Soudure Inox 316L a√©ronautique", remove_accents_flag=True)

# G√©n√©rer un slug pour un identifiant
slug = slugify("Soudure Inox")  # -> 'soudure-inox'

# Mesurer latence encodage
with Timer() as t:
    encode_texts(["Soudure"], "fr")
print(f"Encoding took {t.elapsed_ms}ms")

# Instrumenter une recherche hybride
@record_metric_wrapper('match.hybrid_search', static_tags={'scope': 'company'},
                       dynamic_tags=lambda: {'tenant_id': get_current_tenant()})
def hybrid_search(query, tenant_id, scope): ...

# Monitorer le dirty ratio
log_metric(METRIC_MATCH_DIRTY_RATIO, 0.05, tags={'tenant_id': 'tenant_123', 'scope': 'company'})

# Typage des filtres
filters: MatchFilters = {"sector": "aeronautique", "region": "nord"}

Curation
from utils_core.utils import slugify
from utils_core.validators import validate_scope
from utils_core.alerts import validate_alerts, merge_alerts
from utils_core.errors import AlertException

# Valider un scope
validate_scope("seo:title")

# G√©n√©rer un slug pour validation
slug = slugify("Concept Validation")  # -> 'concept-validation'

# Valider et fusionner des alertes de validation
alerts = validate_alerts([{"type": "validation", "field": "concept", "message": "Invalid"}])
merged = merge_alerts([alerts], dedupe_on="type_field_message", prefer="last")

# Lever une erreur avec alertes
raise AlertException("Validation failed", alerts=[{"type": "validation", "field": "concept", "message": "Invalid"}])

LLM_ai
from utils_core.utils import retry_on_exception, Timer
from utils_core.text_cleaning import normalize_text
from utils_core.env import get_env_variable

# Normaliser un prompt
prompt = normalize_text("Summarize this text", remove_accents_flag=True)

# R√©essayer un appel LLM
@retry_on_exception(exception_types=(LLMError, TimeoutError), max_attempts=3)
def enrich_text(text): ...

# Mesurer latence appel LLM
with Timer() as t:
    enrich_text("Summary")
print(f"LLM call took {t.elapsed_ms}ms")

# R√©cup√©rer timeout LLM
timeout = get_env_variable("LLM_TIMEOUT", cast="float", default=5.0)

M√©triques Attendues
Liste des m√©triques standardis√©es export√©es via constants.py et metrics.py pour monitoring :

match.query.latency_ms: Latence des recherches hybrides (matching).
match.vector.hits: Nombre de hits vectoriels (matching).
match.index.dirty_ratio: Taux de d√©synchronisation des index (matching).
match.index_latency_ms: Latence d'indexation (matching).
match.recall_k: Rappel √† k pour √©valuation des recherches (matching).
match.faiss_hit_rate: Taux de hits FAISS (matching).
match.fusion_component_share: Poids des composants dans fusion (matching).
lang.bulk.latency_ms: Latence des traductions batch (language).
lang.cache.hit: Hits cache pour langues actives/d√©faut (language).
lang.cache.miss: Miss cache pour langues actives/d√©faut (language).


üß™ Tests
Les tests unitaires sont regroup√©s dans tests/test_utils_core/, avec un fichier par module :

test_utils.py
test_validators.py
test_text_cleaning.py
test_env.py
test_metrics.py
test_alerts.py
test_integration.py (tests int√©gr√©s mockant language/matching)
etc.

Tests int√©gr√©s dans test_integration.py simulent les usages dans les apps :

language: Translation.source_checksum, normalize_locale
matching: normalize_text pour queries, record_metric_wrapper
curation: validate_alerts, AlertException
LLM_ai: retry_on_exception, get_env_variable


üìå Bonnes pratiques

Ne pas inclure de logique m√©tier dans utils_core.
Ajouter une fonction uniquement si elle est utilis√©e par ‚â• 2 apps.
Documenter chaque ajout dans ce README.
Pr√©f√©rer l‚Äôajout d‚Äôun nouveau fichier plut√¥t que de m√©langer les r√¥les.


üõ†Ô∏è Maintenance
Les migrations de fonctions depuis les apps vers utils_core doivent √™tre :

Document√©es dans MIGRATIONS.md
Ex. : compute_checksum migr√© depuis language/services.py pour centraliser SHA256 (idempotence embeddings/traductions).
Ex. : normalize_locale migr√© depuis language/services.py pour centraliser normalisation BCP-47 (language, matching, LLM_ai).
Ex. : retry_on_exception ajout√© pour centraliser retries robustes (language tasks, matching encodage, LLM_ai appels).


Accompagn√©es de tests unitaires
Refactor√©es dans les apps via core_imports.py ou alias temporaires

</code></pre>
</body>
</html>