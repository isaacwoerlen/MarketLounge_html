<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>README_faiss_pgvector.md</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>README_faiss_pgvector.md</h1>
    <pre><code>ğŸ“˜ README â€” App faiss_pgvector

Ce fichier respecte les conventions dÃ©crites dans [README Brief Technique.md](../README Brief Technique.md), situÃ© Ã  la racine du dossier apps/.Il dÃ©crit lâ€™objectif, le type, les composants, lâ€™intÃ©gration, et les responsabilitÃ©s internes de lâ€™app.


ğŸ§© Type dâ€™app



Type
Description



Transversale
Fournit un moteur de vectorisation et de recherche sÃ©mantique



Cette app est transversale, utilisÃ©e par toutes les apps verticales (ex: language, glossary, champs SEO/OG) pour encoder des textes en vecteurs et effectuer des recherches sÃ©mantiques rapides. Elle nâ€™appelle jamais les apps mÃ©tier (dÃ©couplage strict).


ğŸ¯ Objectif
Lâ€™app faiss_pgvector est conÃ§ue pour :

Encoder des textes en vecteurs via sentence-transformers.
Stocker les vecteurs dans PostgreSQL via lâ€™extension pgvector.
Indexer les vecteurs localement avec FAISS pour des recherches rapides.
Fournir une API interne stable (services.py) pour les apps mÃ©tier (si besoin)
Supporter le multi-tenancy via tenant_id et les recherches par scope.
Permettre des recherches hybrides (pgvector + FAISS) pour prÃ©cision et vitesse.
Monitorer les performances des index FAISS (taille, latence).


ğŸ¤” Pourquoi pgvector ? Pourquoi FAISS ?
ğŸ”¹ pgvector

Stockage persistant des vecteurs dans PostgreSQL.
RequÃªtes SQL vectorielles avec opÃ©rateurs (<->, cosine).
Index vectoriel (ivfflat) pour top-k rapide.
Compatible avec filtres SQL (scope, tenant_id, langue).
IdÃ©al pour volumes modÃ©rÃ©s ou requÃªtes hybrides.

ğŸ”¹ FAISS

Indexation en mÃ©moire pour recherches ultra-rapides.
OptimisÃ© pour volumes massifs (>100k vecteurs).
Top-k en temps quasi rÃ©el.
Moins flexible pour filtres complexes.
NÃ©cessite gestion des fichiers .index et synchronisations.


ğŸ§  pgvector vs FAISS : qui fait quoi ?



Fonction
pgvector
FAISS



Stockage persistant
âœ… Oui
âŒ Non (fichiers .index)


RequÃªtes SQL hybrides
âœ… Oui
âŒ Non


Recherche top-k rapide
âš ï¸ Moyenne
âœ… Excellente


ScalabilitÃ© (millions de vecteurs)
âš ï¸ Limite serveur SQL
âœ… TrÃ¨s bonne


FacilitÃ© de dÃ©ploiement
âœ… IntÃ©grÃ© PostgreSQL
âš ï¸ NÃ©cessite gestion des index


AuditabilitÃ© / debug
âœ… TrÃ¨s lisible
âŒ Peu lisible



ğŸ”® Ã‰volution possible des rÃ´les



Phase du projet
RÃ´le de pgvector
RÃ´le de FAISS



MVP
Stockage principal + recherches
Indexation secondaire pour top-k


Scale-up
Stockage persistant + hybrid
Recherche primaire + sharding


Mature
Backup + audits
Recherche optimisÃ©e + clustering



ğŸ§± ModÃ¨le(s) principal(aux)
Pas de modÃ¨les propres, mais un mixin abstrait pour les apps mÃ©tier, dÃ©fini dans models.py :
from pgvector.django import VectorField
from django.conf import settings
from django.db import models

class EmbeddingMixin(models.Model):
    embedding = VectorField(dim=settings.EMBEDDING_DIM, null=True, blank=True)

    class Meta:
        abstract = True

Exemple dans language :
from transversales.faiss_pgvector.models import EmbeddingMixin

class Translation(EmbeddingMixin):
    key = models.ForeignKey(TranslatableKey, on_delete=models.CASCADE)
    language = models.CharField(max_length=10)
    text = models.TextField()
    # embedding hÃ©ritÃ© de EmbeddingMixin

Exemple dans glossary :
from transversales.faiss_pgvector.models import EmbeddingMixin

class GlossaryNode(EmbeddingMixin):
    definition = models.TextField()
    # embedding hÃ©ritÃ© de EmbeddingMixin


ğŸ§  Logique mÃ©tier

Encodage : encode_text(text: str) -> np.ndarray utilise sentence-transformers pour gÃ©nÃ©rer un vecteur normalisÃ© L2 (dim=EMBEDDING_DIM, float32).
Stockage : store_vector(obj, vector: np.ndarray) met Ã  jour le champ embedding via pgvector.
Recherche : search_similar(vector: np.ndarray, scope: str, top_k: int = 10, tenant_id: str | None = None) -> List[Result] utilise FAISS (IndexFlatIP, ou pgvector si FAISS_ENABLED=False) avec filtre par tenant_id et scope.
Synchronisation : TÃ¢che Celery sync_embeddings aligne pgvector et FAISS.
Monitoring : TÃ¢che monitor_index collecte stats (taille index, temps de recherche).

Flux avec language :

Traduction batch :
language.services.batch_translate_scope appelle LLM_ai.services.translate_text.
Traduction stockÃ©e via store_translation.
Vectorisation via encode_text/store_vector (async si LANG_EMBED_SYNC=False).
language.tasks.run_vectorize_scopes appelle faiss_pgvector.services.upsert.


Recherche sÃ©mantique :
language.services appelle encode_text et search_similar pour suggestions de traductions.
RÃ¨gles de rÃ©utilisation (score minimum, placeholders) gÃ©rÃ©es dans language.


Rebuild FAISS :
language pousse Translation.embedding via faiss_pgvector.services.build.




ğŸ” RÃ¨gles de recherche

Normalisation : Les embeddings sont normalisÃ©s (L2) dans encode_text pour cohÃ©rence.
MÃ©trique : Utilise vector_cosine_ops pour pgvector et IndexFlatIP pour FAISS (cosine similarity, vecteurs normalisÃ©s).
CohÃ©rence : Les scores entre pgvector et FAISS sont alignÃ©s grÃ¢ce Ã  la normalisation L2.


ğŸ”Œ IntÃ©grations externes

sentence-transformers : Encodage des textes.
pgvector : Stockage des vecteurs (extension PostgreSQL vector).
FAISS : Indexation rapide (fichiers .index).
LLM_ai : Enrichissement sÃ©mantique avant vectorisation (ex: paraphrase via Mistral).
Apps mÃ©tier : Consomment via transversales.faiss_pgvector.services.

Exemple multi-tenant :
from transversales.faiss_pgvector.services import encode_text, search_similar

vector = encode_text("Hello world")
results = search_similar(vector, scope="translation", tenant_id="tenant1")
# Dans language : vÃ©rifier score > 0.9 et placeholders intacts


â± TÃ¢ches Celery

sync_embeddings : Synchronise pgvector -> FAISS pour un scope/tenant.
recalculate_embeddings : Recalcule embeddings pour un scope donnÃ©.
monitor_index : Collecte stats (taille index, temps de recherche).


ğŸ“‚ Structure interne de lâ€™app
transversales/faiss_pgvector/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ apps.py
â”œâ”€â”€ models.py            # EmbeddingMixin pour apps mÃ©tier
â”œâ”€â”€ services.py          # API publique: encode_text, store_vector, search_similar, upsert, build
â”œâ”€â”€ tasks.py             # sync_embeddings, recalculate_embeddings, monitor_index
â”œâ”€â”€ management/
â”‚   â””â”€â”€ commands/
â”‚       â””â”€â”€ sync_faiss_index.py
â”œâ”€â”€ specific/
â”‚   â”œâ”€â”€ embeddings.py
â”‚   â”œâ”€â”€ pgvector_backend.py
â”‚   â”œâ”€â”€ faiss_backend.py
â”‚   â””â”€â”€ fixtures/
â”‚       â””â”€â”€ faiss_index_empty.index
â””â”€â”€ tests/
    â”œâ”€â”€ test_services.py
    â”œâ”€â”€ test_embeddings.py
    â”œâ”€â”€ test_pgvector_backend.py
    â”œâ”€â”€ test_faiss_backend.py
    â”œâ”€â”€ test_tasks.py
    â”œâ”€â”€ test_models.py
    â””â”€â”€ factories.py


ğŸ§­ RÃ¨gles de structuration

Pas de dÃ©pendance aux apps mÃ©tier (ex: language, glossary).
API publique via services.py (from transversales.faiss_pgvector.services import encode_text).
Fichiers backend dans specific/ (embeddings.py, pgvector_backend.py, faiss_backend.py).
Mixin dans models.py (EmbeddingMixin).
Index FAISS persistÃ©s en faiss_index/<tenant>/<scope>.index.
TÃ¢ches Celery pour cohÃ©rence pgvector/FAISS.


ğŸ“¦ IntÃ©gration dans les apps mÃ©tier
Exemple avec language :
from transversales.faiss_pgvector.services import encode_text, store_vector, search_similar
from transversales.faiss_pgvector.models import EmbeddingMixin

def vectorize_translation(translation):
    vector = encode_text(translation.text)
    store_vector(translation, vector)
    translation.save()  # Persistance par language
    similar = search_similar(vector, scope="translation", tenant_id=translation.key.tenant_id)
    # VÃ©rifier score > 0.9 et placeholders dans language

Exemple avec glossary :
from pgvector.django import VectorField
from django.conf import settings
from transversales.faiss_pgvector.services import encode_text, store_vector
from transversales.faiss_pgvector.models import EmbeddingMixin

class GlossaryNode(EmbeddingMixin):
    definition = models.TextField()
    # embedding hÃ©ritÃ© de EmbeddingMixin

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        vector = encode_text(self.definition)
        store_vector(self, vector)


ğŸš€ Recommandations pour scalabilitÃ©

Indexing : Index ivfflat sur embedding avec vector_cosine_ops.
Sharding : Partitionner par tenant_id et scope (ex: faiss_index/<tenant>/<scope>.index).
Performance : Tester avec 10M+ vecteurs via factory_boy. Limiter RAM FAISS (ex: 16GB par index).
Multi-tenancy : Filtrer par tenant_id dans search_similar.
Batching : Utiliser bulk_update pour pgvector, batch pour FAISS upsert.
MÃ©moire FAISS : Monitorer RAM via monitor_index et limiter taille index par tenant/scope.


ğŸ“› Conventions de nommage

Champs : snake_case (ex: embedding).
TÃ¢ches Celery : run_vectorize_scopes, sync_embeddings, monitor_index.
Commandes CLI : sync_faiss_index.py.
Scopes : snake_case ou hiÃ©rarchique (ex: translation, glossary:node).
Index FAISS : <tenant>/<scope>.index.


ğŸ§‘â€ğŸ’» Changements rÃ©cents

Ajout faÃ§ade services.py pour API stable.
DÃ©placement backends dans specific/ (embeddings.py, pgvector_backend.py, faiss_backend.py).
Support multi-tenant via tenant_id dans search_similar.
Setting EMBEDDING_DIM pour cohÃ©rence.
Standardisation sur .index pour FAISS (remplace .npy du Brief Technique, Ã  mettre Ã  jour).
TÃ¢che monitor_index pour performances.
Normalisation L2 pour cohÃ©rence cosine.
Ajout de models.py pour hÃ©berger EmbeddingMixin, centralisant la logique de VectorField.


ğŸ§ª Tests

Localisation : transversales/faiss_pgvector/tests/.
Framework : pytest, factory_boy, pytest-cov.
Cas testÃ©s :
encode_text : Dimension correcte (EMBEDDING_DIM), dtype float32, normalisation L2.
store_vector : Stockage dans pgvector.
search_similar : RÃ©sultats top-k, filtrage par tenant_id/scope.
sync_embeddings : CohÃ©rence pgvector/FAISS.
monitor_index : Stats (taille, latence).
EmbeddingMixin : Champ embedding avec VectorField(dim=EMBEDDING_DIM).




ğŸ“‚ Fixtures

specific/fixtures/faiss_index_empty.index : Index FAISS vide pour initialisation.
Chargement via commande sync_faiss_index.py pour crÃ©er des index par tenant_id/scope.


ğŸ§ª Conclusion
Lâ€™app faiss_pgvector est robuste, scalable, et prÃªte pour lâ€™IA sÃ©mantique. Elle respecte les frontiÃ¨res de README Brief Technique.md, centralise la vectorisation/recherche, et sâ€™intÃ¨gre avec language, glossary, et champs SEO/OG. Les tests et le multi-tenancy sont prioritaires pour gros volumes.</code></pre>
</body>
</html>