<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>README Brief Technique_V03.md</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>README Brief Technique_V03.md</h1>
    <pre><code>ğŸ“˜ README â€” Apps MarketLounge

Introduction
Conventions de dÃ©veloppement
Structure du projet
Stack Technique
Apps transverses
language
seo
LLM_ai
matching
media
taxonomy
metrics
permissions
utils_core


Apps verticales
glossary
company
dico
market
curation
logs
activation
api


Vectorisation & Recherche SÃ©mantique
StratÃ©gie dâ€™interactions inter-apps
DÃ©pendances entre Apps
RÃ¨gles dâ€™Architecture
Conventions de Nomage
Squelette app_exemple
PrioritÃ©s DÃ©veloppement
Verticales de base (Sprint 1 â€“ J3â†’J5)
Activation (Sprint 1 â€“ J5)
Matching + Vectorisation (Sprint 2 â€“ J1â†’J4)
Logs & explicabilitÃ© (Sprint 2 â€“ J4)
TÃ¢ches offline & cron (Sprint 2 â€“ J5)
SÃ©curitÃ© & API (Sprint 3 â€“ J1)
CI / QualitÃ© / Tests (Sprint 3 â€“ J1â†’J2)
Monitoring & VPS (Sprint 3 â€“ J2â†’J3)
Backlog immÃ©diat
Seed minimal
Changements depuis V01

Introduction
Ce rÃ©pertoire contient toutes les applications Django du projet MarketLounge, divisÃ©es en :

Verticales : SpÃ©cifiques Ã  un domaine mÃ©tier (ex. : glossary, market, matching, dico, curation).
Transverses : Services techniques rÃ©utilisables (ex. : language, seo, utils_core).

Ce document est alignÃ© avec README_Architecture du Lounge_V07.md, dÃ©taillant les flux (offline â†’ runtime â†’ apprentissage). Les apps respectent le principe no-overlap : chaque app a un rÃ´le unique (ex. : dico pour gÃ©nÃ©ration concepts offline, matching pour matching runtime hybrid avec FAISS/pgvector/Redis).
Conventions de dÃ©veloppement

Chaque app possÃ¨de un README.md dÃ©crivant objectif, modÃ¨les, vues, tÃ¢ches, etc.
Apps transverses (language, seo, utils_core) ne dÃ©pendent pas des verticales.
Apps verticales consomment les transverses via mixins, helpers ou modÃ¨les abstraits.
Tests organisÃ©s dans apps/<app>/tests/ avec pytest, couverture >80%.
Fichiers respectent la structure dÃ©finie dans app_exemple/.
Docstrings au format Google pour lisibilitÃ©, avec exemples et types explicites.

Structure du projet
MarketLounge/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ transversales/ â† Services rÃ©utilisables
â”‚   â”‚   â”œâ”€â”€ language/
â”‚   â”‚   â”œâ”€â”€ seo/
â”‚   â”‚   â”œâ”€â”€ media/
â”‚   â”‚   â”œâ”€â”€ taxonomy/
â”‚   â”‚   â”œâ”€â”€ utils_core/
â”‚   â”‚   â”œâ”€â”€ metrics/
â”‚   â”‚   â”œâ”€â”€ permissions/
â”‚   â”‚   â””â”€â”€ LLM_ai/
â”‚   â”œâ”€â”€ verticales/ â† Apps mÃ©tier
â”‚   â”‚   â”œâ”€â”€ activation/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ company/
â”‚   â”‚   â”œâ”€â”€ glossary/
â”‚   â”‚   â”œâ”€â”€ logs/
â”‚   â”‚   â”œâ”€â”€ market/
â”‚   â”‚   â”œâ”€â”€ matching/ â† Inclut FAISS/pgvector
â”‚   â”‚   â”œâ”€â”€ dico/
â”‚   â”‚   â””â”€â”€ curation/
â”‚   â””â”€â”€ README/ â† ModÃ¨les README
â”‚       â”œâ”€â”€ README Brief Technique.md
â”‚       â”œâ”€â”€ README_app_exemple.md
â”‚       â””â”€â”€ README_glossary.md
â”œâ”€â”€ config/ â† Django/Celery config
â”‚   â”œâ”€â”€ settings.py
â”‚   â”œâ”€â”€ asgi.py
â”‚   â”œâ”€â”€ urls.py
â”‚   â”œâ”€â”€ wsgi.py
â”‚   â””â”€â”€ celery.py
â”œâ”€â”€ faiss_index/ â† Index FAISS persistÃ©s
â”œâ”€â”€ logs/ â† Logs applicatifs
â”œâ”€â”€ staticfiles/ â† Fichiers statiques
â”œâ”€â”€ venv/ â† Environnement virtuel
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ check_encoding.py
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ manage.py
â”œâ”€â”€ nginx.conf
â””â”€â”€ requirements.txt

Stack Technique



Composant
Technologie



Backend
Django + REST Framework


Base de donnÃ©es
PostgreSQL + pgvector


Vector DB
FAISS (.index)


UI
Django Templates + htmx


Style
Tailwind CSS (CDN)


Authentification
Django auth


DÃ©ploiement
Docker + nginx


IA locale
sentence-transformers


TÃ¢ches asynchrones
Celery + django_celery_beat


Cache
Redis (pour rÃ©sultats matching)


API externe
societe.com


API IA
Mistral API


Apps transverses
language
Objectif : Traduction automatique des champs via Mistral API.Fonctionnement : Centralise langues activÃ©es ; traduit champs marquÃ©s ; Ã©vite duplication (ex. : label_fr).IntÃ©gration : Importer mixins/fonctions dans modÃ¨les ; utiliser helpers dans vues/serializers.Exemple :
from transversales.language.services import batch_translate_items
batch_translate_items(item_ids=["node_1"], fields=["label"], source_lang="fr", target_langs=["en"])

DoD : Traduction automatique des labels dans glossary.
seo
Objectif : Injection champs SEO/OpenGraph dans modÃ¨les.Fonctionnement : Utilise SEOblock mixin ; traduit via language ; gÃ©nÃ¨re balises meta.IntÃ©gration : Ajouter SEOblock dans modÃ¨les ; utiliser helpers dans templates/serializers.DoD : Balises meta gÃ©nÃ©rÃ©es dans market (ex. : <meta name="description" content="...">).
LLM_ai
Objectif : Enrichissements sÃ©mantiques via LLM (Mistral, OpenAI).Fonctionnement : GÃ©nÃ¨re rÃ©sumÃ©s, suggestions ; expose API interne.IntÃ©gration : Utiliser helpers dans services.py/tasks.py des verticales.DoD : Stub rerank dans matching.fuse_and_score via LLM_ai.
matching
Objectif : Matching runtime hybrid (lexical + vectoriel) avec vectorisation/recherche sÃ©mantique.DÃ©pendances : LLM_ai, taxonomy, utils_core.Fonctionnement : Encode via sentence-transformers ; stocke vecteurs pgvector ; index FAISS (.index) ; rerank via LLM ; cache rÃ©sultats Redis (DoD : cache hit >80%).IntÃ©gration : Helpers (encode_text, store_vector, search_similar) ; synchronise index via Celery.Exemple :
from utils_core.text_cleaning import normalize_text
from verticales.matching.services import encode_text
query = normalize_text("Soudure Inox 316L", remove_accents_flag=True)
vector = encode_text(query)

media
Objectif : Gestion multimÃ©dias (images, vidÃ©os, documents).Fonctionnement : Stockage/mÃ©tadonnÃ©es ; associe Ã  contenus.IntÃ©gration : Importer modÃ¨les/helpers pour associer fichiers.
taxonomy
Objectif : Gouvernance types/rÃ´les/structures mÃ©tier.Fonctionnement : DÃ©finit taxonomies rÃ©utilisables (catÃ©gories, tags, hiÃ©rarchies).IntÃ©gration : Utiliser modÃ¨les/helpers pour appliquer taxonomies.
metrics
Objectif : Suivi enrichissements, alertes, usages.Fonctionnement : Collecte mÃ©triques (recherches, IA) ; expose rapports via Prometheus/StatsD.IntÃ©gration : Importer helpers pour enregistrer mÃ©triques.Exemple :
from utils_core.metrics import log_metric
log_metric("match.query.latency_ms", 150.5, {"scope": "company"}, tenant_id="tenant_123")

permissions
Objectif : Droits dâ€™accÃ¨s mutualisÃ©s.Fonctionnement : RÃ¨gles granulaires par rÃ´le/entreprise ; dÃ©corateurs/mixins.IntÃ©gration : Appliquer dans views.py/serializers.py.
utils_core
Objectif : Fonctions utilitaires transverses (JSON, dates, formats).Fonctionnement : Centralise helpers techniques sans logique mÃ©tier (ex. : compute_checksum, normalize_text).Philosophie du module : Fournir des utilitaires gÃ©nÃ©riques utilisÃ©s par â‰¥2 apps, sans logique mÃ©tier, avec docstrings Google et tests >80% couverture.IntÃ©gration : Importer dans verticales/transverses via from utils_core import ....DÃ©pendances : tenacity, numpy, python-decouple, ijson (optionnel).Exemple :
from utils_core import compute_checksum, normalize_text, stream_json_loads
checksum = compute_checksum("Soudure inox 316L")
query = normalize_text("<p>CafÃ© franÃ§ais</p>", remove_accents_flag=True)
data = list(stream_json_loads('[{"id": 1}, {"id": 2}]'))

Tests : ExÃ©cuter avec pytest tests/test_utils_core/ --cov=utils_core.
Apps verticales



App
DÃ©pendances transverses
Multi-tenancy



glossary
language, seo, LLM_ai, media, taxonomy, matching
âœ… (tenant_id sur nÅ“uds)


company
language, seo, media, LLM_ai
âœ… (tenant_id sur profils)


dico
LLM_ai, taxonomy
âœ… (tenant_id sur concepts)


market
language, matching, taxonomy, metrics
âœ… (tenant_id sur offres)


curation
language, seo, media, taxonomy, matching, LLM_ai
âœ… (tenant_id sur validations)


logs
metrics, permissions
âœ… (tenant_id sur logs)


activation
permissions, metrics
âœ… (tenant_id sur activations)


api
language, seo, matching, taxonomy
âœ… (tenant_id sur requÃªtes)


glossary
Objectif : Structurer savoir-faire industriels (dÃ©finitions, termes).Fonctionnement : GÃ¨re termes avec dÃ©finitions, traductions, SEO ; utilise matching pour recherches sÃ©mantiques.IntÃ©gration : ModÃ¨les avec SEOblock ; traduction via language ; vectorisation via matching.DoD : Traduction automatique des labels via language (ex. : label_fr â†’ label_en).
company
Objectif : GÃ©rer donnÃ©es entreprise (fiches, SIREN).Fonctionnement : IntÃ¨gre via API Societe.com ; enrichit rÃ©sumÃ©s IA.IntÃ©gration : ModÃ¨les avec SEOblock ; traduction via language.
dico
Objectif : GÃ©nÃ©ration offline concepts activables (Dictionnaire SÃ©mantique).Fonctionnement : Parse facettes ; valide via Glossaire ; enrichit statiquement (synonymes, embeddings).IntÃ©gration : Helpers pour matching (usage runtime), curation (validation).
market
Objectif : Gestion offres/demandes ; analyse marchÃ© (tensions, raretÃ©s).Fonctionnement : CrÃ©ation/recherche offres ; utilise matching pour recommandations ; croise offre/demande.IntÃ©gration : Recherche via matching ; suivi via metrics.DoD : Balises SEO gÃ©nÃ©rÃ©es via seo (ex. : <meta name="keywords" content="...">).
curation
Objectif : Curation contenus (sÃ©lection, validation humaine).Fonctionnement : SÃ©lectionne/organise contenus ; valide proposals ; enrichit via dico.IntÃ©gration : ModÃ¨les avec SEOblock ; traduction via language ; recherche via matching.
logs
Objectif : Historiser actions, enrichissements, alertes (query_match_log).Fonctionnement : Enregistre Ã©vÃ©nements ; fournit rapports ; trace request_ID.IntÃ©gration : Enregistrement via signaux/tÃ¢ches ; feedback Ã  curation.
activation
Objectif : Activation comptes/onboarding/rÃ´les ; index activations concepts.Fonctionnement : Flux inscription ; applique rÃ´les ; index activations pour matching.IntÃ©gration : SÃ©curisation via permissions ; suivi via metrics.
api
Objectif : Endpoints publics/internes.Fonctionnement : Expose donnÃ©es verticales via REST ; intÃ¨gre recherches sÃ©mantiques.IntÃ©gration : Serializers/vues pour exposer donnÃ©es.
Vectorisation & Recherche SÃ©mantique
GÃ©rÃ©e par matching :  

Encodage : sentence-transformers (multi-lang out-of-box).  
Stockage : pgvector PostgreSQL.  
Indexation : FAISS (.index, IVF/HNSW, auto-backup via Celery task).  
Synchronisation : Celery/commande CLI.  
Cache : Redis pour rÃ©sultats runtime (DoD : cache hit >80%).

Exemple :
from utils_core.text_cleaning import normalize_text_batch
from verticales.matching.services import encode_text
texts = ["Soudure Inox", "Usinage 5 axes"]
vectors = encode_text(normalize_text_batch(texts))

StratÃ©gie dâ€™interactions inter-apps
Contexte
Apps verticales (glossary, market) appellent les transverses (language, utils_core) via un modÃ¨le pull (appels Python directs). Migration HTTP prÃ©vue pour complexitÃ© accrue (ex. : microservices, dashboards). FastAPI considÃ©rÃ© pour services Ã  haute frÃ©quence (language, LLM_ai, matching) dans V1.1+.
Approche Actuelle : Appels Python Directs

ModÃ¨le Pull : Apps verticales appellent services transverses (ex. : language.services.batch_translate_items) via clients encapsulÃ©s (ex. : glossary/services/language_client.py).
Exemple :from transversales.language.services import batch_translate_items
class Term(models.Model):
    def save(self, *args, **kwargs):
        batch_translate_items(item_ids=[self.id], fields=["name"], source_lang="fr", target_langs=["en"])


Avantages : Performance (pas de latence rÃ©seau), simplicitÃ©, sÃ©curitÃ©.

Migration Future : Interactions HTTP

Quand migrer : ComplexitÃ© accrue (ex. : language comme microservice), dashboards internes, dÃ©couplage.
Mise en Å“uvre :
Clients avec switch dynamique (ex. : USE_LANGUAGE_HTTP=true pour requests.post).
Endpoints REST dans urls.py, views.py, serializers.py (actuellement commentÃ©s, LANG_ENABLE_API=False).
SÃ©curitÃ© : IsAdminUser, throttling lÃ©ger (ex. : 200/min).



DÃ©pendances entre Apps



App verticale
DÃ©pendances transverses
Multi-tenancy



glossary
language, seo, LLM_ai, media, taxonomy, matching
âœ… (tenant_id sur nÅ“uds)


company
language, seo, media, LLM_ai
âœ… (tenant_id sur profils)


dico
LLM_ai, taxonomy
âœ… (tenant_id sur concepts)


market
language, matching, taxonomy, metrics
âœ… (tenant_id sur offres)


curation
language, seo, media, taxonomy, matching, LLM_ai
âœ… (tenant_id sur validations)


logs
metrics, permissions
âœ… (tenant_id sur logs)


activation
permissions, metrics
âœ… (tenant_id sur activations)


api
language, seo, matching, taxonomy
âœ… (tenant_id sur requÃªtes)


Interdictions : Transverses ne dÃ©pendent pas de verticales ; pas de logique mÃ©tier spÃ©cifique ; pas de modification directe.
RÃ¨gles dâ€™Architecture

DÃ©finition : Transverses fournissent services techniques/sÃ©mantiques (ex. : traduction, SEO). Pas de logique mÃ©tier ; interfaces gÃ©nÃ©riques.
Principe MaÃ®trise : Verticales contrÃ´lent contexte/dÃ©clenchement (pull) ; transverses fournissent rÃ©sultats sans initiative.
Exemple : glossary appelle seo avec titre/dÃ©finition ; seo retourne balises ; glossary dÃ©cide usage.

Conventions de Nomage



Ã‰lÃ©ment
Convention



App transverse
snake_case, technique (language, seo)


App verticale
snake_case, mÃ©tier (glossary, dico)


ModÃ¨le principal
PascalCase, singulier (GlossaryNode)


Fichier mÃ©tier
services.py (logique), utils.py (helpers)


Champ traduisible
labels, definition (JSONField)


TÃ¢che Celery
run_generate_X, sync_embeddings_X


Commande CLI
enrich_X.py, sync_faiss_index.py


Squelette app_exemple
apps/
â””â”€â”€ transversales|verticales/
    â”œâ”€â”€ <app_name>/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ apps.py          # Config Django
    â”‚   â”œâ”€â”€ models.py        # ModÃ¨les
    â”‚   â”œâ”€â”€ admin.py         # Admin
    â”‚   â”œâ”€â”€ forms.py         # Formulaires
    â”‚   â”œâ”€â”€ serializers.py   # SÃ©rialisation
    â”‚   â”œâ”€â”€ views.py         # ContrÃ´leurs
    â”‚   â”œâ”€â”€ services.py      # Logique mÃ©tier
    â”‚   â”œâ”€â”€ urls.py          # Routage
    â”‚   â”œâ”€â”€ tasks.py         # TÃ¢ches Celery
    â”‚   â”œâ”€â”€ utils.py         # Helpers
    â”‚   â”œâ”€â”€ signals.py       # Ã‰vÃ©nements
    â”‚   â”œâ”€â”€ permissions.py   # AccÃ¨s
    â”‚   â”œâ”€â”€ management/commands/ # CLI
    â”‚   â”œâ”€â”€ templates/admin/ # Templates admin
    â”‚   â”œâ”€â”€ static/         # JS/CSS
    â”‚   â”œâ”€â”€ specific/fixtures/ # Fixtures
    â””â”€â”€ tests/              # Tests pytest




Ordre
Fichier
RÃ´le
FrontiÃ¨re



[0]
apps.py
DÃ©clare app
Pas logique mÃ©tier


[1]
models.py
Structure donnÃ©es
Pas encoding/enrichissement


[2]
services.py
Logique mÃ©tier
Pas HTTP/serializers


[3]
serializers.py
Formatage
Pas logique complexe


[4]
views.py
ContrÃ´leurs
DÃ©lÃ¨gue Ã  services.py


[5]
urls.py
Routage
Pas logique


[6]
admin.py
Admin
Pas complexe


[7]
forms.py
Validation
Pas services externes


[8]
tasks.py
TÃ¢ches Celery
DÃ©lÃ¨gue Ã  services.py


[9]
signals.py
Ã‰vÃ©nements
DÃ©lÃ¨gue Ã  services.py


[10]
permissions.py
AccÃ¨s
Pas traitement donnÃ©es


[11]
management/commands/
CLI
DÃ©lÃ¨gue Ã  services.py


[12]
templates/admin/
Templates
Pas Python


[13]
static/*.js
JS
Pas backend


[14]
static/*.css
CSS
Pas backend


[15]
fixtures/
DonnÃ©es test
Pas logique


PrioritÃ©s DÃ©veloppement



App transverse
PrioritÃ©



language
ğŸ”¥ Haute


LLM_ai
ğŸ”¥ Haute


taxonomy
âš¡ Moyenne


media
âš¡ Moyenne


seo
ğŸŒ± Basse


metrics
ğŸŒ± Basse


permissions
ğŸŒ± Basse


utils_core
ğŸŒ± Basse


Verticales de base (Sprint 1 â€“ J3â†’J5)

glossary : GlossaryNode(node_id, type, parent, path, labels, description, explication_technique, status/version), admin optimisÃ©e, appel translate_fields avant save.DoD : CrÃ©ation/validation dâ€™un nÅ“ud, path auto, traduction labels via language.  
company : CompanyProfile(company_id, facettes JSON, source, flags) (collecte brute).DoD : POST via DRF.
dico : Concept(concept_ID, labels, definition, synonyms, related_to, embedding NULL, glossary_node_ids), offline only.DoD : CLI propose_concept_from_glossary (draft).

Activation (Sprint 1 â€“ J5)

activation : CompanyConceptActivation(company_id, concept_ID, facettes, evidence, is_claimed), build offline depuis company + dico.DoD : Commande activation.build_from_profiles qui peuple lâ€™index.

Matching + Vectorisation (Sprint 2 â€“ J1â†’J4)
Une seule app matching embarquant vectorisation (FAISS/pgvector) en modules internes.  

Stub vectoriel : Mock FAISS avec liste simple pour tester lexical seul (J1).  
Full FAISS : ImplÃ©mentation complÃ¨te (J3).

ModÃ¨les / stockage

Embeddings : StockÃ©s en pgvector (PostgreSQL).  
Index FAISS : Persistant dans faiss_index/ (IVF/HNSW, auto-backup via Celery).

services.py (matching)

encode_text(text) : Via sentence-transformers.
search_lexical(query, corpus=dico.labels+synonyms) : Normalisation + fuzzy.
search_vector(query) : Encode â†’ interroge FAISS (cosine/sim) avec stub (J1) et full implÃ©mentation (J3).
fuse_and_score(lex, vec) : Union pondÃ©rÃ©e (ex. : 0.6/0.4), seuils adaptatifs, stub rerank via LLM_ai.
filter_by_activation(shortlist, company_activation) : Filtre final runtime.
sync_faiss_index() : Commande/task Celery pour (rÃ©)gÃ©nÃ©rer .index.DoD :
sync_faiss_index produit un .index exploitable.
search_vector() interroge lâ€™index (perfs OK en dev).
/api/match renvoie shortlist cohÃ©rente (fusion lexical+vectoriel, filtrÃ©e).
Cache hit >80% via Redis.



views.py (matching)

POST /api/match : Payload {query, filters?} â†’ {shortlist: [...], explain: {scores, sources}}.

Logs & explicabilitÃ© (Sprint 2 â€“ J4)

logs : QueryMatchLog(request_ID UUID, raw_text, matched_concepts, scores, rationale) ; hook post-fusion.DoD : Chaque /api/match crÃ©e un log consultable.

TÃ¢ches offline & cron (Sprint 2 â€“ J5)

Celery Beat :
Glossaire : Mensuel (signalement fusions).
Dico : Bimensuel (revalidation).
Company : Hebdo (rescan modifs).DoD : TÃ¢ches Â« no-op Â» sâ€™exÃ©cutent et journalisent correctement.



SÃ©curitÃ© & API (Sprint 3 â€“ J1)

Auth token/clÃ©, rate limiting (Nginx/django-ratelimit), CORS si front sÃ©parÃ©.DoD : /api/match protÃ©gÃ© (401 si non autorisÃ©).

CI / QualitÃ© / Tests (Sprint 3 â€“ J1â†’J2)

GitHub Actions : ruff/flake8, black, pytest + couverture.  
Tests critiques : matching.services (fusion/filtre), language (cache/validators), sync_faiss_index, utils_core (validators, metrics).DoD : Pipeline vert, >80% couverture sur matching.services, utils_core.

Monitoring & VPS (Sprint 3 â€“ J2â†’J3)

/health, Uptime Kuma ou Prometheus/Grafana ; VPS Docker Compose (web, db, FAISS, Redis, Nginx, Certbot).  
Backups : pg_dump + faiss_index/*.index.DoD : Domaine + HTTPS opÃ©rationnels, backup vÃ©rifiÃ©.

Backlog immÃ©diat

language : ModÃ¨les, services, tests (incl. traduction labels).
glossary : ModÃ¨le/admin, path auto.
company : API POST.
dico : Concept draft, CLI.
activation : Build offline.
matching : Lexical â†’ vectoriel (stub J1, FAISS J3) â†’ sync_faiss_index â†’ /api/match.

Seed minimal

10 nÅ“uds Glossaire, 20 Concepts (labels/synonyms/definition), 5 CompanyProfiles, 10 Activations.  
Objectif : Valider /api/match dÃ¨s la fin de la fusion matching+vectorisation.

Changements depuis V01

Fusion Matching/Vectorisation : ClarifiÃ© en "Sprint 2 J1-4" (supprime confusion J1-3 vs J3-4). Stub search_vector (J1) avec mock FAISS (liste simple), full FAISS J3.
DoD ajoutÃ©s :
Multilingue : Traduction labels dans glossary via language.
SEO : Balises meta dans market via seo.
IA : Stub rerank dans matching.fuse_and_score via LLM_ai.
Cache : Redis pour matching (cache hit >80%).
Backup : Auto-backup FAISS index via Celery task.


utils_core :
MigrÃ© Timer vers time_utils.py (renommÃ© timer), retry_on_exception vers decorators.py.
AjoutÃ© normalize_text_batch (NumPy) dans text_cleaning.py pour traitement batch.
AjoutÃ© stream_json_loads (ijson) dans json_utils.py pour gros payloads.
AjoutÃ© validate_json_schema dans validators.py pour payloads complexes.
IntÃ©grÃ© tenant_id dans metrics.py pour multi-tenancy.
AjoutÃ© cache LRU dans env.get_env_variable.
Docstrings uniformisÃ©s en Google pour lisibilitÃ©.


</code></pre>
</body>
</html>