<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>README_language.md</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>README_language.md</h1>
    <pre><code>üìò README ‚Äî App language
Ce fichier respecte les conventions de [README Brief Technique_V02.md](../README Brief Technique_V02.md). Il d√©crit l'objectif, le type, les composants, l'int√©gration, et les responsabilit√©s de l'app language.
üß© Type d‚ÄôApp
Type : TransversaleDescription : Service r√©utilisable pour la traduction multilingue, appel√© via pull par les verticales (ex. : glossary, market). Fournit une gestion centralis√©e des langues, traductions automatiques via LLM, et vectorisation s√©mantique pour la recherche via l'app matching.
üéØ Objectif

Centralise la traduction automatique via LLM_ai (Mistral API) avec retries robustes.
G√®re les langues actives et par d√©faut avec cache (TTL 60s).
Orchestre les jobs batch asynchrones (Celery) avec mode dry-run pour pr√©visualisation.
Supporte la scalabilit√© multi-tenancy (millions de traductions).
Int√®gre la vectorisation pour recherche s√©mantique (via matching).
Valide les contraintes SEO (longueur, placeholders) avec m√©triques de performance.

üß± Mod√®les Principaux
üóÇÔ∏è Language



Champ
Type
Description



code
CharField(10)
Code langue (ex. : fr, regex ^[a-z]{2}(-[a-z]{2})?$)


name
CharField(100)
Nom lisible (ex. : Fran√ßais)


is_active
BooleanField
Active traduction (default: True)


is_default
BooleanField
Langue d√©faut (unique, default: False)


priority
IntegerField
Priorit√© batch (1=haute, default: 5)


created_at
DateTimeField
Auto-cr√©ation


updated_at
DateTimeField
Auto-mise √† jour



Contraintes : Unicit√© code ; une seule is_default=True ; langue par d√©faut active.
Index : is_active, priority.
Comportements : Normalisation code (lowercase, tiret) via save() ; cache via LanguageManager (TTL configurable via settings.LANG_CACHE_TTL).

üõ°Ô∏è Endpoints Potentiels (Migration HTTP)

Actuellement comment√©s (LANG_ENABLE_API=False), mais pr√™ts pour activation en V1.1+.
Exemple dans urls.py :
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import TranslationJobViewSet

router = DefaultRouter()
router.register(r'jobs', TranslationJobViewSet)

urlpatterns = [
    path('api/v1/language/', include(router.urls)),  # Ex. : /api/v1/language/jobs/
]

Exemple de vue dans views.py (ViewSet avec permissions) :
from rest_framework import viewsets, permissions
from .models import TranslationJob
from .serializers import TranslationJobSerializer

class TranslationJobViewSet(viewsets.ModelViewSet):
    queryset = TranslationJob.objects.all()
    serializer_class = TranslationJobSerializer
    permission_classes = [permissions.IsAdminUser]  # S√©curis√©
    throttle_classes = []  # Throttling l√©ger (ex. : 200/min)

    def perform_create(self, serializer):
        # Logique custom : d√©clenche Celery task apr√®s cr√©ation
        instance = serializer.save()
        run_batch_translation_job.delay(instance.id)  # Async via Celery

Exemple de requ√™te POST √† /api/v1/language/jobs/ :
{
    "name": "Batch Traduction Glossary",
    "source_locale": "fr",
    "target_locales": ["en", "es"],
    "scope_filter": ["glossary:*"],
    "tenant_id": "tenant_123"
}

R√©ponse : 201 Created avec stats initiales.


üóÇÔ∏è TranslatableKey

Champ
Type
Description

scope
CharField(64)
Contexte (ex. : glossary, seo)

key
CharField(255)
Cl√© unique dans scope (ex. : label)

checksum
CharField(64)
Hash SHA256 scope:key (via signal)

is_blocking
BooleanField
Bloque publication si non traduit (default: False)

prompt_template
JSONField
Template pour LLM (default: {})

tenant_id
CharField(36)
Multi-tenancy (ex. : tenant_xxx, null=True, valid√© via regex)

created_at
DateTimeField
Auto-cr√©ation

updated_at
DateTimeField
Auto-mise √† jour


Contraintes : Unicit√© scope + key.
Index : scope, key, checksum, tenant_id.
Comportements : Validation tenant_id (regex ^tenant_[a-zA-Z0-9_]+$).

üóÇÔ∏è Translation

Champ
Type
Description

key
ForeignKey
Cl√© traduite

language
ForeignKey
Langue cible

text
TextField
Texte traduit

version
IntegerField
Version (default: 1)

alerts
JSONField
Alertes SEO (ex. : [{"type": "seo_length", "message": "..."}])

embedding
VectorField
Vecteur s√©mantique (dim configurable via settings.LANG_EMBEDDING_DIM, default: 384)

source_checksum
CharField(64)
Hash texte source

origin
CharField(20)
Origine (human, llm, tm)

provider_info
JSONField
Info LLM (ex. : {"provider": "mistral"})

domain
CharField(32)
Contexte domaine (null=True)

created_at
DateTimeField
Auto-cr√©ation

updated_at
DateTimeField
Auto-mise √† jour


Contraintes : Unicit√© key, language, version ; version >= 1.
Index : language, key+language, updated_at, source_checksum, domain.
Comportements : Validation alerts (liste de dicts), provider_info (dict).

üóÇÔ∏è TranslationJob

Champ
Type
Description

name
CharField(255)
Nom du job

state
CharField(20)
√âtat (pending, running, done, failed)

source_locale
CharField(5)
Langue source

target_locales
JSONField
Langues cibles

scope_filter
JSONField
Scopes (ex. : ["homepage", "seo:*"])

stats
JSONField
Statistiques (ex. : {"processed": 100, "per_lang": {"fr": 50}})

errors
JSONField
Erreurs (liste de cha√Ænes)

glossary_ids
JSONField
IDs items (ex. : glossary IDs)

tenant_id
CharField(36)
Multi-tenancy (ex. : tenant_xxx, null=True)

created_at
DateTimeField
Auto-cr√©ation

updated_at
DateTimeField
Auto-mise √† jour


Permissions : rerun_translationjob, export_translationjob.
Index : state, created_at, tenant_id.

üõ†Ô∏è Composants Internes
üóÑÔ∏è Fichiers Principaux

models.py : D√©finit mod√®les avec contraintes, index, cache (LanguageManager), et signaux pour checksums.
services.py : Logique m√©tier (ex. : store_translation, batch_translate_items) avec retries LLM via tenacity.
tasks.py : T√¢ches Celery (run_batch_translation_items, run_batch_translation_scope, run_vectorize_scopes) avec validation et m√©triques.
signals.py : Automatismes pour cache TM et vectorisation async avec m√©triques.
admin.py : Interface admin avec actions (rerun_job, export_results), s√©curis√©e (CSRF, permissions).
views.py : API REST (ViewSets) avec permissions, filtres √©tendus (ex. : origin, source_checksum), et error handling.
serializers.py : Validation/s√©rialisation API avec contraintes (ex. : unicit√© scope+key).
utils.py : Normalisation (normalize_locale), cache (get_active_langs), et traduction batch (translate_fields).
permissions.py : Permissions granulaires pour multi-tenancy (ex. : can_view_translation).
management/commands/sync_translations.py : CLI pour sync/async traductions avec dry-run.
static/language/language_admin.js : UX admin (normalisation code, warnings, spinner) avec ARIA et i18n.
static/language/language_admin.css : Styles admin responsifs avec namespace .language-admin.
fixtures/languages.json : Fixture pour langues initiales (fr, en, pt-br, es) avec priority.
templates/admin/language/translation_job.html : Template admin pour TranslationJob avec sanitisation XSS et responsivit√©.

üß™ Tests

Tests unitaires recommand√©s (non fournis) dans tests/ avec pytest :

test_models.py : Contraintes, cache LanguageManager, validation tenant_id.
test_services.py : store_translation, retries LLM, validation SEO.
test_admin.py : Actions rerun_job, export_results, permissions.
test_views.py : API REST, permissions, filtres.
test_commands.py : CLI sync_translations (dry-run, args).
test_js.py : JS language_admin.js avec Jest (normalisation, ARIA).


Couverture : Viser >80% pour services.py, models.py (pytest-cov).

Outils : Flake8, Ruff, Black pour linting ; Jest pour JS.


üß™ Int√©gration dans une App Verticale
Les verticales (ex. : glossary) appellent language via pull. Exemple dans glossary :
from transversales.language.services import batch_translate_items
from verticales.matching.services import encode_text

class Term(models.Model):
    id = models.CharField(max_length=36, primary_key=True)
    label = models.CharField(max_length=255)
    definition = models.TextField()

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        batch_translate_items(
            item_ids=[self.id],
            fields=["label", "definition"],
            source_lang="fr",
            target_langs=["en", "es"],
            tenant_id="tenant_123",
        )
        self.embedding = encode_text(self.definition)  # Via matching

üîß Comportements Automatiques

Normalisation : Language.code (ex. : pt-BR ‚Üí pt-br).
Cache : TTL 60s pour get_active_langs/get_default_lang ; TM 1h pour tm_lookup.
Checksum : Calcul√© via signaux pre_save pour TranslatableKey/Translation.
Vectorisation : Async via post_save sur Translation (Celery si settings.LANG_EMBED_SYNC=False).
Multi-tenancy : Validation tenant_id via regex ^tenant_[a-zA-Z0-9_]+$.
Idempotence : Skip si source_checksum inchang√© dans store_translation.
Retries LLM : 3 tentatives avec backoff exponentiel pour translate_text.
M√©triques : Enregistrement via metrics pour traductions, vectorisations, et erreurs.

üß¨ Exemples de Payloads JSON

alerts : [{"type": "seo_length", "field": "title", "message": "Too long (65 chars)"}]
scope_filter : ["homepage", "seo:*"]
target_locales : ["fr", "de"]
stats : {"total_keys": 120, "translated": 85, "per_lang": {"fr": 40}, "origin_breakdown": {"llm": 80, "tm": 5}}
prompt_template : {"tone": "formal", "max_length": 100}
provider_info : {"provider": "mistral", "model": "large-latest"}

üß† Int√©gration avec LLM_ai et Matching

- **LLM_ai** : Traductions via `transversales.LLM_ai.services.translate_text` avec retries (tenacity). Pr√©paration des prompts dans `services.py`.
- **Matching** : Vectorisation via `verticales.matching.services.encode_text` pour `Translation.embedding` (VectorField, dimension configurable via `settings.LANG_EMBEDDING_DIM`, d√©faut 384). D√©clench√©e async par signal `post_save` (Celery si `settings.LANG_EMBED_SYNC=False`). Un index HNSW avec `vector_cosine_ops` (configurable via `settings.LANG_VECTOR_OPCLASS`) optimise les recherches s√©mantiques multilingues. Les embeddings doivent √™tre normalis√©s (L2) avant stockage pour garantir la pr√©cision des recherches cosine.

üöÄ Recommandations Scalabilit√©

Indexing : Index compos√©s sur Translation(key, language), TranslatableKey(scope, key).
Sharding : Partition par tenant_id ou scope.
Batching : Wildcards (seo:*) et settings.LANG_BATCH_SIZE (d√©faut: 200).
Performance : Tester 10M+ traductions avec factory_boy.
Monitoring : M√©triques via transversales.metrics (ex. : traductions par langue, erreurs LLM).
Cache : Redis recommand√© pour TM et r√©sultats runtime (cache hit >80%).

üìõ Conventions Nomage

Champs : snake_case (ex. : source_locale).
T√¢ches Celery : run_batch_translation_*.
Commandes CLI : sync_translations.py.
Scopes : snake_case ou hi√©rarchique (ex. : seo:title).

üß™ Tests Recommand√©s

Mod√®les : Contraintes (unicit√©, version >= 1), cache LanguageManager.
Services : Idempotence store_translation, retries LLM, validation SEO.
Admin : Actions s√©curis√©es (CSRF, permissions).
CLI : Dry-run, validation args.
JS : Normalisation code, ARIA avec Jest.

üß™ Conclusion
L'app language est robuste, scalable, et pr√™te pour l'IA s√©mantique. Elle respecte les fronti√®res du Brief V02, centralise les appels IA via LLM_ai, et int√®gre les verticales via pull. Prioriser les tests pour gros volumes/multi-tenancy et l'int√©gration Redis pour cache.</code></pre>
</body>
</html>